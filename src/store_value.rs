// src/store_value.rs
use std::any::{Any, TypeId};
use std::collections::HashMap;

/// A trait that combines Any + Clone for value-based storage.
pub trait CloneAny: Any + Send + Sync {
    /// Clone this value into a boxed trait object.
    fn clone_any(&self) -> Box<dyn CloneAny>;
    /// Get a reference to the underlying Any.
    fn as_any(&self) -> &dyn Any;
    /// Get a mutable reference to the underlying Any.
    fn as_any_mut(&mut self) -> &mut dyn Any;
}

impl<T: Clone + Any + Send + Sync> CloneAny for T {
    fn clone_any(&self) -> Box<dyn CloneAny> {
        Box::new(self.clone())
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
}

// Implement Clone for Box<dyn CloneAny> - this is the key trick
// NOTE: Must use (**self) to call the inner type's clone_any, not the Box's
impl Clone for Box<dyn CloneAny> {
    fn clone(&self) -> Self {
        (**self).clone_any()
    }
}

/// A cloneable, value-based container that stores exactly one value per type.
///
/// Unlike `TypeStore`, `TypeStoreValue` does not use `Arc<Mutex<>>` internally,
/// making it cloneable and suitable for single-threaded contexts or when you
/// need to snapshot state.
///
/// # Examples
///
/// ```
/// use sovran_typemap::TypeStoreValue;
///
/// #[derive(Clone, Debug, PartialEq)]
/// struct Config {
///     debug: bool,
///     max_retries: u32,
/// }
///
/// let mut store = TypeStoreValue::new();
///
/// store.set(Config { debug: true, max_retries: 3 });
/// store.set(42i32);
///
/// // Clone the entire store
/// let snapshot = store.clone();
///
/// // Modify original
/// store.with_mut::<Config, _, _>(|cfg| {
///     cfg.debug = false;
/// });
///
/// // Snapshot is unchanged
/// assert_eq!(snapshot.get::<Config>().unwrap().debug, true);
/// assert_eq!(store.get::<Config>().unwrap().debug, false);
/// ```
#[derive(Default, Clone)]
pub struct TypeStoreValue {
    items: HashMap<TypeId, Box<dyn CloneAny>>,
}

impl std::fmt::Debug for TypeStoreValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TypeStoreValue")
            .field("len", &self.items.len())
            .finish()
    }
}

impl TypeStoreValue {
    /// Creates a new, empty TypeStoreValue.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let store = TypeStoreValue::new();
    /// assert!(store.is_empty());
    /// ```
    pub fn new() -> Self {
        Self {
            items: HashMap::new(),
        }
    }

    /// Stores a value, using its type as the key.
    ///
    /// If a value of this type already exists, it will be replaced.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    ///
    /// store.set(42i32);
    /// store.set("hello".to_string());
    ///
    /// // Overwrites the previous i32
    /// store.set(100i32);
    /// assert_eq!(store.get::<i32>(), Some(100));
    /// ```
    pub fn set<V>(&mut self, value: V)
    where
        V: Clone + Any + Send + Sync,
    {
        self.items.insert(TypeId::of::<V>(), Box::new(value));
    }

    /// Stores a value generated by a closure.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    ///
    /// store.set_with(|| vec![1, 2, 3, 4, 5]);
    ///
    /// assert_eq!(store.get::<Vec<i32>>(), Some(vec![1, 2, 3, 4, 5]));
    /// ```
    pub fn set_with<V, F>(&mut self, f: F)
    where
        V: Clone + Any + Send + Sync,
        F: FnOnce() -> V,
    {
        self.set(f());
    }

    /// Retrieves a clone of a value by its type.
    ///
    /// Returns `None` if no value of this type exists.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    /// store.set(42i32);
    ///
    /// assert_eq!(store.get::<i32>(), Some(42));
    /// assert_eq!(store.get::<String>(), None);
    /// ```
    pub fn get<V>(&self) -> Option<V>
    where
        V: Clone + Any + Send + Sync,
    {
        self.with(|v: &V| v.clone())
    }

    /// Accesses a value by type with a read-only closure.
    ///
    /// Returns `None` if no value of this type exists.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    /// store.set(vec![1, 2, 3, 4, 5]);
    ///
    /// let sum = store.with::<Vec<i32>, _, _>(|numbers| {
    ///     numbers.iter().sum::<i32>()
    /// });
    /// assert_eq!(sum, Some(15));
    /// ```
    pub fn with<V, F, R>(&self, f: F) -> Option<R>
    where
        V: Any,
        F: FnOnce(&V) -> R,
    {
        self.items
            .get(&TypeId::of::<V>())
            .and_then(|boxed| (**boxed).as_any().downcast_ref::<V>())
            .map(f)
    }

    /// Accesses a value by type with a read-write closure.
    ///
    /// Returns `None` if no value of this type exists.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    /// store.set(vec![1, 2, 3]);
    ///
    /// store.with_mut::<Vec<i32>, _, _>(|numbers| {
    ///     numbers.push(4);
    ///     numbers.push(5);
    /// });
    ///
    /// assert_eq!(store.get::<Vec<i32>>(), Some(vec![1, 2, 3, 4, 5]));
    /// ```
    pub fn with_mut<V, F, R>(&mut self, f: F) -> Option<R>
    where
        V: Any,
        F: FnOnce(&mut V) -> R,
    {
        self.items
            .get_mut(&TypeId::of::<V>())
            .and_then(|boxed| (**boxed).as_any_mut().downcast_mut::<V>())
            .map(f)
    }

    /// Removes a value by its type.
    ///
    /// Returns `true` if a value was removed, `false` if no value of that type existed.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    /// store.set(42i32);
    ///
    /// assert!(store.remove::<i32>());
    /// assert!(!store.remove::<i32>()); // Already removed
    /// ```
    pub fn remove<V: Any>(&mut self) -> bool {
        self.items.remove(&TypeId::of::<V>()).is_some()
    }

    /// Checks if a value of the given type exists.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    ///
    /// assert!(!store.contains::<i32>());
    /// store.set(42i32);
    /// assert!(store.contains::<i32>());
    /// ```
    pub fn contains<V: Any>(&self) -> bool {
        self.items.contains_key(&TypeId::of::<V>())
    }

    /// Gets the number of values in the store.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    /// assert_eq!(store.len(), 0);
    ///
    /// store.set(42i32);
    /// store.set("hello".to_string());
    /// assert_eq!(store.len(), 2);
    /// ```
    pub fn len(&self) -> usize {
        self.items.len()
    }

    /// Checks if the store is empty.
    ///
    /// # Examples
    ///
    /// ```
    /// use sovran_typemap::TypeStoreValue;
    ///
    /// let mut store = TypeStoreValue::new();
    /// assert!(store.is_empty());
    ///
    /// store.set(42i32);
    /// assert!(!store.is_empty());
    /// ```
    pub fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    struct TestConfig {
        name: String,
        value: i32,
    }

    #[derive(Clone, Debug, PartialEq)]
    struct AnotherConfig {
        enabled: bool,
    }

    #[test]
    fn test_set_and_get() {
        let mut store = TypeStoreValue::new();

        store.set(TestConfig {
            name: "test".to_string(),
            value: 42,
        });

        let config = store.get::<TestConfig>().unwrap();
        assert_eq!(config.name, "test");
        assert_eq!(config.value, 42);
    }

    #[test]
    fn test_multiple_types() {
        let mut store = TypeStoreValue::new();

        store.set(TestConfig {
            name: "test".to_string(),
            value: 42,
        });
        store.set(AnotherConfig { enabled: true });
        store.set(123i32);
        store.set("hello".to_string());

        assert_eq!(store.get::<TestConfig>().unwrap().value, 42);
        assert!(store.get::<AnotherConfig>().unwrap().enabled);
        assert_eq!(store.get::<i32>().unwrap(), 123);
        assert_eq!(store.get::<String>().unwrap(), "hello");
    }

    #[test]
    fn test_overwrite() {
        let mut store = TypeStoreValue::new();

        store.set(42i32);
        assert_eq!(store.get::<i32>(), Some(42));

        store.set(100i32);
        assert_eq!(store.get::<i32>(), Some(100));

        // Still only one item
        assert_eq!(store.len(), 1);
    }

    #[test]
    fn test_clone() {
        let mut store = TypeStoreValue::new();
        store.set(TestConfig {
            name: "original".to_string(),
            value: 42,
        });
        store.set(100i32);

        // Clone the store
        let snapshot = store.clone();

        // Modify original
        store.with_mut::<TestConfig, _, _>(|cfg| {
            cfg.name = "modified".to_string();
            cfg.value = 99;
        });
        store.set(200i32);

        // Snapshot should be unchanged
        assert_eq!(snapshot.get::<TestConfig>().unwrap().name, "original");
        assert_eq!(snapshot.get::<TestConfig>().unwrap().value, 42);
        assert_eq!(snapshot.get::<i32>(), Some(100));

        // Original should be modified
        assert_eq!(store.get::<TestConfig>().unwrap().name, "modified");
        assert_eq!(store.get::<TestConfig>().unwrap().value, 99);
        assert_eq!(store.get::<i32>(), Some(200));
    }

    #[test]
    fn test_with() {
        let mut store = TypeStoreValue::new();
        store.set(vec![1, 2, 3, 4, 5]);

        let sum = store.with::<Vec<i32>, _, _>(|v| v.iter().sum::<i32>());
        assert_eq!(sum, Some(15));

        // Non-existent type
        let result = store.with::<String, _, _>(|s| s.len());
        assert_eq!(result, None);
    }

    #[test]
    fn test_with_mut() {
        let mut store = TypeStoreValue::new();
        store.set(vec![1, 2, 3]);

        store.with_mut::<Vec<i32>, _, _>(|v| {
            v.push(4);
            v.push(5);
        });

        assert_eq!(store.get::<Vec<i32>>(), Some(vec![1, 2, 3, 4, 5]));
    }

    #[test]
    fn test_remove() {
        let mut store = TypeStoreValue::new();
        store.set(42i32);

        assert!(store.contains::<i32>());
        assert!(store.remove::<i32>());
        assert!(!store.contains::<i32>());
        assert!(!store.remove::<i32>());
    }

    #[test]
    fn test_contains() {
        let mut store = TypeStoreValue::new();

        assert!(!store.contains::<i32>());
        store.set(42i32);
        assert!(store.contains::<i32>());
    }

    #[test]
    fn test_len_and_is_empty() {
        let mut store = TypeStoreValue::new();

        assert!(store.is_empty());
        assert_eq!(store.len(), 0);

        store.set(42i32);
        assert!(!store.is_empty());
        assert_eq!(store.len(), 1);

        store.set("hello".to_string());
        assert_eq!(store.len(), 2);

        store.remove::<i32>();
        assert_eq!(store.len(), 1);
    }

    #[test]
    fn test_set_with() {
        let mut store = TypeStoreValue::new();

        store.set_with(|| TestConfig {
            name: "lazy".to_string(),
            value: 99,
        });

        let config = store.get::<TestConfig>().unwrap();
        assert_eq!(config.name, "lazy");
        assert_eq!(config.value, 99);
    }

    #[test]
    fn test_not_found_returns_none() {
        let store = TypeStoreValue::new();

        assert_eq!(store.get::<TestConfig>(), None);
        assert_eq!(store.with::<i32, _, _>(|v| *v), None);
    }

    #[test]
    fn test_debug() {
        let mut store = TypeStoreValue::new();
        store.set(42i32);
        store.set("hello".to_string());

        let debug_str = format!("{:?}", store);
        assert!(debug_str.contains("TypeStoreValue"));
        assert!(debug_str.contains("len"));
        assert!(debug_str.contains("2"));
    }
}
